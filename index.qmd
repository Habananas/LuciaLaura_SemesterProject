---
title: A Travel Mode Detection approach based on hierarchical and non hierarchical clustering
subtitle: Patterns and Trends in Environmental Data
author: Lucia Scheele and Laura Vetter
format:
  html:
    code-fold: true # makes the code in the output collapsable
execute:
  warning: false # hides warnings from the generated output
  message: false        # hides messages from the generated output
lang: en  # switch to "de" if you write your report in german
bibliography: bibliography.bib
---

```{r}
#| code-summary: preprocessing #name des Code Chunks

#loading all the data from the preprocessing files
load("my_environment.rdata")
#load("selected_tracks.rda") (besser weil man dann nur lädt was man wirklich braucht)

library(tmap) #to show data in map viewer, is necesary in 

``` 

## Abstract

This project aims to analyze travel behaviour and clustering of travel segments by different clustering methods and visual analysis. 
Parameters like speed, acceleration, elevation and sinuosity and derived parameters were used for clustering with kmeans and hmeans. Simultaneously, a segmentation by threshold (using the parameter speed) and a manual segmentation using GIS were carried out to compare them to the clustering. 
Verification took place using Chi square test and ANOVA ?????

The results show that 

- 5 clusters, which corresponds to the actual amount of travel modes (+standing)
- hmeans predicts better than kmeans 
- the ward method in hmeans is better than ...
- xxx showed a better (or equally good) result than manual classification. 
-  Verification method 
- ...
BEARBEITEN 

## Introduction
BEARBEITEN 

In order to understand travel behaviour, it is critical to analyze movement data and be able to classify different types of movement correctly (@sadeghian2022stepwise). 
However, the exact detection of the corresponding travel modes is complex and can be time consuming.  
Generic methodologies to detect travel modes have been described using unsupervised learning algorithms, GIS multi-criteria process (eg. by @sadeghian2022stepwise), and supervised learning algorithms or decision trees and confusion matrix(@shamoun2012sensor).
This project aims to answer the reasearch question of which travel modes can be differentiated in trajectories with different travel modes within the trajectories using hierarchical and non-hierarical clustering?
Therefore, the project focuses on a comparison of these two clustering methods, and a comparison with a manual segmentation using ArcGIS and a threshold segmentation using the parameter speed.


Auch reinbringen?:
@laube2011 investigate how temporal scale affects the calculation of movement parameters (speed, sinuosity and turning angle) of animal trajectories. 



## Material and Methods

### Data
The data sample consists of movement data collected with the Tracking App Strava, by two individuals over a timespan of April - May 2024.
Overall, 31 trips of different travel modes were recorded with the movement types walking, running, cycling, bus, tram, train and car. For simplification of the  design and to be able to focus on the application of the clustering methods, a sample of 2 trips with different movement types within the trajectory were selected to be analyzed.
Data points were recorded every second, resulting in a relatively high resolution of data. However, data frequency is not consistent in all cases due to lack of signal (e.g. in a train). 

At first, it was considered to include contextual data such as traffic infrastructure data by the city of Zurich ( [https://www.stadt-zuerich.ch/geodaten/](#0){.uri}), however these are categorical data and are therefore not suitable for the evaluation with the k-means clustering algorithm.


### Clustering 

Some of the trajectories include several travel modes. The aim of this project is to verify if it is possible to detect different travel modes within one trajectory using clustering. 
To determine the number of clusters needed, the trajectory data is analysed with   (functions).  
5 different travel modes could be identified in the samples (walking, running, tram, bike, train), therefore the optimal number of clusters expected is 5. 
Space and time of trajectories were treated to be relative and are filtered out for the analysis.
The parameters for clustering will be calculated from the given geographical data and include:
- distance point1 - point2
- speed p1 - p2
- acceleration p1 - p2
- mean speed in moving window 
- max speed in moving window
- mean acceleration in moving window 
- max acceleration in moving window
- elevation change in moving window 
- sinuosity in moving window

The calculation of sinuosity, some adaptions needed to be made as some values had the value "Inf". This occurs when the direct distance = 0, meaning that start and end point of the moving window are the same. The actual moving distance is >1, as within the moving window movement occured. 

actual moving distance /direct distance = x/0=Inf  

There are several ways to deal with this problem: 
1) Set inf values to the maximum value of the sinuosity 
2) Filter out values completely from the table
3) Insert the actual distance traveled per 10 points,  actual/direct=x/x=1 

The third method was chosen, resulting in the lowest sinuosity value possible (=1).


#### Classification via threshold  


The following segmentation was made: (vllt lieber decision tree statt den code?)
```{r}
selected_tracks  <- selected_tracks  |>
  mutate(manual_cluster = case_when(
    speed_kmh == 0 ~ "1", #standing
    speed_kmh < 5 ~ "2", #walking
    speed_kmh >= 5 & speed_kmh < 18 ~ "3",  #running
    speed_kmh >= 18 & speed_kmh >= 30 ~ "4", # velo 
    speed_kmh < 30 ~ "5" # tram
  ))
```
Problem: 
inhomogenous segments, bc the threshold is set at a point where it varies constantly (e.g. speed>5 = running, speed<5 = walking - differs constantly )
Resolving with manual classification in GIS.

### Verification with manual classification in GIS

(DESCRIPTION OF WHAT WE DID)
```{r}
#map von GIS  
```


#### kmeans

K means is one of the most commonly used partition based algorithms (@yuan2017review), where k defines the number of clusters and is identified before processing. Each partition is one cluster and contains at least one data point, where each data point is assigned to only one cluster.
Initially, a k-means algorithm should have been used that takes categorical (such as infrastructure data) and numerical variables into account, however this was not possible with the k-mode() function, and also, the infrastructural data taken into account was not overlapping with the trajectories in all cases. Therefore, the focus was set on the analysis of the numerical data.


#### hmeans
(LUCIA?)

chaining erklären (deshlab ward am besten)


## Results

2 trajectories were chosen which include several travel modes. 

```{r}
tmap_mode("view")
tm_shape(selected_tracks)+ 
  tm_dots(col = "trajID", palette = "Paired") +
  tm_view(set.view = c(8.524527, 47.390118,  16))

```
### parameters

```{r}
tm_shape(selected_tracks)+
  tm_dots(col = "speed_kmh", palette = "RdYlGn") 

tm_shape(selected_tracks)+
  tm_dots(col = "el_change", palette = "RdYlGn") 


tm_shape(selected_tracks)+
  tm_dots(col = "manual_cluster", palette = "RdYlGn",
          n =3 ,
          breaks = seq(1, 3, by = 0.1)) 
```

### k means  (non hierarchical clustering)

#### partitioning 
There are severeal methods to define the appropriate amount of clusters for kmeans, one of them being the elbow method (https://www.datanovia.com/en/lessons/determining-the-optimal-number-of-clusters-3-must-know-methods/#elbow-method) and anotherone the Gap Statistic Method. 
Using the fviz_nbclust() function from the factoextra package, the right amount of clusters was identified. 

```{r}
plot_k_elbow

```
In the elbow statistic, the best amount of clusters seems to be 2(???), as the curve starts to bend there.  

```{r}
#plot_k_gapstat #processing takes very long... therefore left out
```
We tried gapstat, but it took to long  to calculate. 
Another method is the cascade (SOURCE LUCIA).
The SSE (sum of squared errors) is a measure of how well the data points are summarized within the clusters. The lower, the better the clustering. In the ssi (silhouette index) the higher the value (from -1 to 1) the better the clustering.
```{r}
cascade_results
```
The SSE is lowest for 5 clusters, which indicates good clustering, and also the ssi is highest in 5 clusters. 
Therefore, we try k means with 4 and 5 clusters. 

#### applying k means 
We left out the n start criterion -> but would have liked to bring in if more time, as running k-means multiple times with different random starts (specified by the nstart parameter) and choosing the best result helps avoid getting stuck in a poor local optimum. 
```{r}
tm_shape(selected_tracks_na_omit)+
  tm_dots(col = "kmeans4", palette = "RdYlGn") 
```
das cluster klappt noch ziemlich schlecht, es clustert zB die standing points gleich wie das laufen. 
Und Strassenbahn und Fahrrad sind ebenfalls gleich

Changing the cluster number to 5:
```{r}
tm_shape(selected_tracks_na_omit)+
  tm_dots(col = "kmeans5", palette = "RdYlGn") 

```
Und auch Kurven mit dem Fahrrad sieht es nicht als solche, sondern klassifiziert sie anders. 

###  hmeans (hierarchical  clustering)
meaning that e.g. cluster bike is closer to running and tram is closer to train 

```{r}
ward_plot
ward_dendro 
```

```{r}
P_ward_4

tmap_arrange(cluster_h_map, cluster_manual_map,cluster_k_map )

```
Works well with differentiation between running and walking, but nbike and tram look the same. 
### Verification

- wir wollen wissen, ob alle punkte, die im GIS cluster den wert 5 haben, im k-cluster den entsprechenden Wert zB 3 haben. Mit welcher verification method? 



Kontrollgruppe (GIS)  und Clustergruppen 
H0: Die Gruppenzuordnungen (Cluster) sind gleich bei Kontroll und Clustergruppen
H1: Die Gruppenzuordnungen (Cluster) sind ungleich bei Kontroll und Clustergruppen


#### CHi2 test? da
```{r}
chi_man_k4
```
Hier kommt eine sehr niedrige Signifikanz raus, das heisst, die beiden clustermethoden sind sehr unterschiedlich. Warum? Weil sie nicht die gleichen Werte für die gleichen Cluster nehmen. Es ist also notwendig, erst die cluster visuell zu überprüfen abzugleichen und dann zuzuweisen, und dann den Test zu wiederholen. 
Oder wir probieren es mit Korrelation

#### ANOVA 

#### t test mit rID Segmentierung 

Erwartetes Ergebnis: der p Wert ist höher, d.h. unsignifikanter als bei t-test ohne rID segmentierung, das heisst die Gruppenzuweisungen sind sich mit rID segmentierung ähnlicher.



## Discussion
zu Bearbeiten:
- turning angles function? 

- change of results when sinuosity inf values different?
- can we extract the parameters by which hmeans clusters? für Vergleich am Ende (wsl nicht)( Laura)
Clustering with single tracks works better than when clustering with all tracks -> method less accurate when using fixes of several trajectories? not generally applicable (reproducible)?
- Validation with GIS  speed information was used, therefore no indepentent control of cluster quality  
- clustering of the corners  (when bike slows down - other cluster) we could have also calculated turn, but there was no time left
- Discussion: If more time & resources, other clustering method that also allows ordinal/categorical variables to be considered

anderes:
- scale/normalisation. Warum normalisieren wir die Werte? Gibt es Nachteile bei einer Normalisierung(look up dengler?)?
- spatial proximity: is dependency of data a disadvantage for clustering? (Lucia)

- was haben wir nochmal mit den Randpunkten gemacht? Also wenns von einem track zum nächsten geht? haben wor dafür eine Function oder so damit die speeds etc nicht verfälscht sind?
- first clustering with only one track & verification with CHi/ANOVA and then with various & verification. -> this tells us wether method is generalizable or not? 


## Appendix

### Wordcount

<!-- after installing the wordcountaddin, remove the line "#| eval: false" -->

```{r}
#for word count:
install.packages("pacman") 
library("pacman")
p_install_gh("benmarwick/wordcountaddin")
wordcountaddin::word_count("index.qmd") 

#knitr::spin("preprocessing.R") --> macht "run" von preprocessing file und produziert html. 

```





